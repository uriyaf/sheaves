from base_sheaf import *
from sheaf_tools import subsheaf_generated_by_1cochains
from random import seed

def no_log(*args, **kwargs):
    pass

class ModificationProcess(object):
    """
    This class imlements the modification process of sheaves by quotients described in a publication by First and Kaufman.
    The stage is unfortunately shifted by 1.
    """

    def __init__(self, sheaf, rand_seed=None):
        """
        If @rand_seed is None, then no seeding is performed.
        """
        self._sheaf = sheaf
        self._E_basis = [] # an array of arrays. The 0th entry is a basis to E0, the i-th entry is a basis to E'_{i}
        if rand_seed is not None:
            seed(rand_seed)

    def get_stage(self):
        return len(self._E_basis) - 1 # should be just len(self._E_basis) in the present version of First-Kaufman

    def get_E_basis(self):
        return sum(self._E_basis, [])

    def get_E_prime_basis(self, r):
        return self._E_basis[r+1]

    def init_from_1cocycle_basis(self, max_cocycles=None, rand_seed=None):
        """
        Initializes E0 using a basis of 1-cocycles.
        If @max_cocycles is specified, then no more than @max_cocycles vectors are used.
        Returns the dimension of E0.
        If @rand_seed is None, then no seeding is performed.
        """
        if rand_seed is not None:
            seed(rand_seed)
        basis = self._sheaf.rand_cohomology_basis(1)
        if max_cocycles is not None:
            basis = basis[:max_cocycles]
        self._E_basis = [basis]
        return len(basis)

    def init_from_1coboundary(self, coboundaries_num=1, rand_seed=None):
        """
        Initializes E0 using @coboundaries_num randomly chosen 1-coboundaries.
        Returns the dimension of E0.
        If @rand_seed is None, then no seeding is performed.
        """
        if rand_seed is not None:
            seed(rand_seed)
        self._E_basis = [[self._sheaf.rand_coboundary(1) for i in range(coboundaries_num)]]
        return coboundaries_num 

    def step(self, rand_seed=None, log=no_log):
        """
        Computes the next step in the process.
        Returns the number of 1-cochains added.
        If @rand_seed is None, then no seeding is performed.
        """
        log("Begin stage %d" % self.get_stage())
        if rand_seed is not None:
            seed(rand_seed)
            log("rand seed set to", rand_seed)
        F = self._sheaf
        log("Computing sheaf C generated by 1-cochains... ", end="", flush=True)
        inc = subsheaf_generated_by_1cochains(F, self.get_E_basis())
        log("done.", flush=True)
        C = inc.source
        log("Computing basis to H^2(C)... ", end="", flush=True)
        H2C_basis = C.cohomology_basis(2) # optional: Use rand_cohomology_basis instead. It shouldn't matter.
        log("done. Basis len =", len(H2C_basis), flush=True)
        log("Computing dual basis to H^2(F)... ", end="", flush=True)
        H2F_dual_basis = F.cohomology_dual_basis(2)
        log("done. Basis len =", len(H2F_dual_basis), flush=True)
        log("Computing basis to ker(H^2(C)->H^2(F)) [Forming matrix]... ", end="", flush=True)
        M = F.mat_class().zero_mat(len(H2F_dual_basis), len(H2C_basis))
        for j,h in enumerate(H2C_basis):
            inc_h = inc(h)
            for i,phi in enumerate(H2F_dual_basis):
                M[i,j] = phi * inc_h
        log("done.")
        log("Computing basis to ker(H^2(C)->H^2(F)) [Solving equations]... ", end="", flush=True)
        N = M.null_space()
        del M
        del H2F_dual_basis
        log("done. Basis len =", N.rows(), flush=True)
        log("Computing basis to E'%d... " % self.get_stage(), end="", flush=True)
        new_1cochains = []
        zero_vec = C.zero_cochain(2) # zero cochain
        #print(N.rows())
        for c in N.get_rows():
            new_1cochains.append(F.source_for_d(inc(linear_combination(c, H2C_basis, zero_vec))) + F.rand_cocycle(1))
        self._E_basis.append(new_1cochains)
        log("done. Basis len =", len(new_1cochains), flush=True)
        return len(new_1cochains)

    

        
